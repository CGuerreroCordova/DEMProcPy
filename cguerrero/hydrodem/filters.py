"""
Provide the abstract class for filters
"""
from abc import ABC, abstractmethod
import copy
from collections import Counter
import numpy as np
from hydrodem.sliding_window import (SlidingWindow, CircularWindow,
                                     NoCenterWindow, IgnoreBorderInnerSliding)
from scipy.ndimage import (binary_erosion, binary_closing, grey_dilation,
                           convolve)
from scipy import fftpack

class Filter(ABC):
    """
    Representd a filter
    """

    @abstractmethod
    def apply(self, *args):
        """
        Apply the filter
        Raises
        ------
        NotImplementedError
            If the method was not implemented in the subclass
        """
        raise NotImplementedError


class ComposedFilter(Filter):

    def __init__(self):
        self.filters = []

    def apply(self, image_to_filter):
        content = image_to_filter
        for filter in self.filters:
            content = filter.apply(content)
        return content


class ComposedFilterResults(Filter):

    def __init__(self):
        self.results = dict()

    def apply(self, image_to_filter):
        content = image_to_filter
        for filter in self.filters:
            content = filter.apply(content)
            self.results[filter.__class__.__name__] = content
        return content


class BitwiseXOR(Filter):

    def __init__(self, *, operand):
        self.operand = copy.deepcopy(operand)

    def apply(self, image_to_filter):
        return np.bitwise_xor(self.operand, image_to_filter)

class MajorityFilter(Filter):
    """
    The value assigned to the center will be the most frequent value,
    contained in a windows of window_size x window_size
    """

    def __init__(self, *, window_size):
        self.window_size = window_size

    def apply(self, image_to_filter):
        filtered_image = np.zeros(image_to_filter.shape)
        sliding = CircularWindow(image_to_filter, self.window_size)
        for window, center in sliding:
            frequency = Counter(window.ravel())
            value, count = frequency.most_common()[0]
            if count > (self.window_size ** 2 - 1) * 0.7:
                filtered_image[center] = value
        return filtered_image


class BinaryErosion(Filter):
    """
    Represents the Mmajority Filter
    """

    def __init__(self, *, iterations):
        self.iterations = iterations

    def apply(self, image_to_filter):
        return binary_erosion(image_to_filter, iterations=self.iterations)


class BinaryClosing(Filter):
    """
    Represents the Mmajority Filter
    """

    def __init__(self, *, structure=None):
        self.structure = structure

    def apply(self, image_to_filter):
        return binary_closing(image_to_filter, structure=self.structure)

class ExpandFilter(Filter):
    """
    The value assigned to the center will be 1 if at least one pixel
    inside the circular window is 1
    """

    def __init__(self, *, window_size):
        self.window_size = window_size

    def apply(self, img_to_expand):
        expanded_image = np.zeros(img_to_expand.shape)
        sliding = CircularWindow(img_to_expand, self.window_size)
        for window, center in sliding:
            window = window[~np.isnan(window)]
            if np.any(window > 0):
                expanded_image[center] = 1
        return expanded_image


class EnrouteRivers(Filter):
    """
    Apply homogeneity to canyons. Specific defined for images with flow stream.
    """

    def __init__(self, *, window_size, dem):
        self.window_size = window_size
        self.dem = copy.deepcopy(dem)

    def apply(self, mask_rivers):
        left_up = self.window_size // 2
        rivers_enrouted = np.zeros(self.dem.shape)
        sliding = SlidingWindow(mask_rivers, window_size=self.window_size,
                                iter_over_ones=True)
        dem_sliding = SlidingWindow(self.dem, window_size=self.window_size)
        for _, (j, i) in sliding:
            window_dem = dem_sliding[j, i]
            neighbour_min = np.amin(window_dem.ravel())
            indices_min = np.nonzero(window_dem == neighbour_min)
            for min_j, min_i in zip(indices_min[0], indices_min[1]):
                indices = (j - left_up + min_j, i - left_up + min_i)
                rivers_enrouted[indices] = 1
                dem_sliding.grid[indices] = 10000
        return rivers_enrouted


class QuadraticFilter(Filter):
    """
    Smoothness filter: Apply a quadratic filter of smoothness
    :param dem: dem image
    """

    def __init__(self, *, window_size):
        self.window_size = window_size

    def apply(self, dem):
        values = np.linspace(-self.window_size / 2 + 1, self.window_size / 2,
                             self.window_size)
        xx, yy = np.meshgrid(values, values)
        r0 = self.window_size ** 2
        r1 = (xx * xx).sum()
        r2 = (xx * xx * xx * xx).sum()
        r3 = (xx * xx * yy * yy).sum()

        dem_sliding = SlidingWindow(dem, window_size=self.window_size)
        smoothed = dem.copy()

        for window, center in dem_sliding:
            s1 = window.sum()
            s2 = (window * xx * xx).sum()
            s3 = (window * yy * yy).sum()
            smoothed[center] = ((s2 + s3) * r1 - s1 * (r2 + r3)) / \
                               (2 * r1 ** 2 - r0 * (r2 + r3))
        return smoothed


class CorrectNANValues(Filter):

    def apply(self, dem):
        """
        Correct values lower than zero, generally with extremely lowest values.
        """
        mask_nan = MaskNegatives().apply(dem)
        sliding_nans = SlidingWindow(mask_nan, window_size=3,
                                     iter_over_ones=True)
        dem_sliding = NoCenterWindow(dem, window_size=3)
        for _, center in sliding_nans:
            neighbours_of_nan = dem_sliding[center].ravel()
            neighbours_of_nan = neighbours_of_nan[~np.isnan(neighbours_of_nan)]
            neighbours_positives = \
                list(filter(lambda x: x >= 0, neighbours_of_nan))
            dem[center] = sum(neighbours_positives) / len(neighbours_positives)
        return dem


class LowerThan(Filter):

    def __init__(self, *, value):
        self.value = value

    def apply(self, image_to_filter):
        # TODO: Condition about values, Exceptions
        return image_to_filter < self.value


class GreaterThan(Filter):

    def __init__(self, *, value):
        self.value = value

    def apply(self, image_to_filter):
        # TODO: Condition about values, Exceptions
        return image_to_filter > self.value


class BooleanToInteger(Filter):

    def apply(self, image_to_filter):
        # TODO: conditions about type of values
        return image_to_filter * 1


class MaskNegatives(ComposedFilter):

    def __init__(self):
        # TODO check to put in properties
        self.filters = [LowerThan(value=0.0), BooleanToInteger()]


class MaskPositives(ComposedFilter):

    def __init__(self):
        self.filters = [GreaterThan(value=0.0), BooleanToInteger()]


class MaskTallTrees(ComposedFilter):

    def __init__(self):
        self.filters = [GreaterThan(value=1.5), BooleanToInteger()]

class IsolatedPoints(Filter):

    def __init__(self, *, window_size):
        self.window_size = window_size

    def apply(self, image_to_filter):
        """
        Remove isolated pixels detected to be part of a mask.
        """
        sliding = NoCenterWindow(image_to_filter, window_size=self.window_size,
                                 iter_over_ones=True)
        for window, center in sliding:
            window = window[~np.isnan(window)]
            image_to_filter[center] = 1. if np.any(window > 0) else 0.
        return image_to_filter


class BlanksFourier(Filter):

    def __init__(self, *, window_size):
        self.window_size = window_size

    def apply(self, image_to_filter):
        """
        Define the filter to detect blanks in a fourier transform image.
        """
        filtered_image = np.zeros(image_to_filter.shape)
        fourier_transform = \
            IgnoreBorderInnerSliding(image_to_filter,
                                     window_size=self.window_size,
                                     inner_size=5)
        for window, center in fourier_transform:
            mean_neighbor = np.nanmean(window)
            real_center = center[0] - self.window_size // 2, \
                          center[1] - self.window_size // 2,
            if image_to_filter[real_center] > (4 * mean_neighbor):
                filtered_image[real_center] = 1.0
        image_modified = image_to_filter * (1 - filtered_image)
        return filtered_image, image_modified


class DetectBlanksFourier(Filter):

    def apply(self, quarter_fourier):
        final_mask_image = np.zeros(quarter_fourier.shape)
        blanks_fourier = BlanksFourier(window_size=55)
        for i in (0, 1):
            filtered_blanks, quarter_fourier = \
                blanks_fourier.apply(quarter_fourier)
            final_mask_image += filtered_blanks
        return final_mask_image


class MaskFourier(ComposedFilter):
    """
    Perform iterations of filter blanks functions and produce a final mask
    with blanks of fourier transform.
    :param quarter_fourier: fourier transform image.
    :return: mask with detected blanks
    """

    def __init__(self):
        # TODO check to put in properties
        self.filters = [DetectBlanksFourier(), IsolatedPoints(window_size=3),
                        ExpandFilter(window_size=13)]


class ProductFilter(Filter):

    def __init__(self, factor=1):
        # TODO Conditions about types.
        self.factor = factor

    def apply(self, factor):
        return self.factor * factor


class AdditionFilter(Filter):

    def __init__(self, adding=0):
        # TODO Conditions about types.
        self.adding = adding

    def apply(self, adding):
        return self.adding + adding


class SubtractionFilter(Filter):

    def __init__(self, *, minuend=0.0):
        self.minuend = minuend

    def apply(self, subtracting):
        return self.minuend - subtracting


class GreyDilation(Filter):

    def __init__(self, *, size):
        self.size = size

    def apply(self, image_to_filter):
        return grey_dilation(image_to_filter, size=self.size)


class TidyingLagoons(ComposedFilter):

    def __init__(self):
        self.filters = [BinaryErosion(iterations=2),
                        ExpandFilter(window_size=7),
                        ProductFilter(),
                        GreyDilation(size=(7, 7))]

    def apply(self, image_to_filter):
        self.filters[2].factor = content = image_to_filter
        for filter in self.filters:
            content = filter.apply(content)
        return content


class LagoonsDetection(ComposedFilterResults):
    def __init__(self):
        super().__init__()
        self.filters = [CorrectNANValues(), MajorityFilter(window_size=11),
                        TidyingLagoons(), MaskPositives()]

    def apply(self, image_to_filter):
        result = super().apply(image_to_filter)

        self.hsheds_nan_fixed = self.results["CorrectNANValues"]
        self.mask_lagoons = self.results["MaskPositives"]
        self.lagoons_values = self.results["TidyingLagoons"]

        return result


class GrovesCorrection(ComposedFilter):

    def __init__(self, tree_class):
        self.partial_results = []
        self.filters = [QuadraticFilter(window_size=15), SubtractionFilter(),
                        MaskTallTrees(), ProductFilter(factor=tree_class),
                        SubtractionFilter(minuend=1)]

    def apply(self, image_to_filter):
        self.filters[1].minuend = content = image_to_filter
        for filter in self.filters:
            content = filter.apply(content)
            self.partial_results.append(copy.deepcopy(content))

        final_addition = AdditionFilter(adding=self.partial_results[0])
        final_product = ProductFilter(factor=self.partial_results[1])
        self.filters = [final_product, final_addition]
        return super().apply(content)


class GrovesCorrectionsIter(ComposedFilter):

    # TODO: Ver de modificar esto
    def __init__(self, tree_class):
        # self.filters = []
        # for i in iterations:
        #     self.filters.append(GrovesCorrection(tree_class))
        self.filters = [GrovesCorrection(tree_class),
                        GrovesCorrection(tree_class),
                        GrovesCorrection(tree_class)]


class ProcessRivers(ComposedFilter):

    def __init__(self, hsheds):
        self.filters = [MaskPositives(), ExpandFilter(window_size=3),
                        EnrouteRivers(window_size=3, dem=hsheds),
                        BinaryClosing()]


class ClipLagoonsRivers(ComposedFilter):

    def __init__(self, mask_lagoons, rivers_routed_closing):
        self.filters = [ProductFilter(factor=mask_lagoons), MaskPositives(),
                        BitwiseXOR(operand=rivers_routed_closing)]


class FourierTransform(Filter):

    def apply(self, image_to_filter):
        return fftpack.fft2(image_to_filter)


class FourierITransform(Filter):

    def apply(self, image_to_filter):
        return fftpack.ifft2(image_to_filter)


class FourierShift(Filter):

    def apply(self, image_to_filter):
        return fftpack.fftshift(image_to_filter)


class FourierIShift(Filter):

    def apply(self, image_to_filter):
        return fftpack.ifftshift(image_to_filter)


class AbsolutValues(Filter):

    def apply(self, image_to_filter):
        return np.abs(image_to_filter)


class Around(Filter):

    def apply(self, image_to_filter):
        return np.around(image_to_filter)


class Convolve(Filter):

    def __init__(self, weights=np.ones((3, 3))):
        self.weights = weights

    def apply(self, image_to_filter):
        return convolve(image_to_filter, weights=self.weights) / \
               self.weights.size


class FourierInitial(ComposedFilter):
    # TODO Cambiar de quien hereda esta clase ComposedFilterResults
    def __init__(self):
        self.results = dict()
        self.filters = [FourierTransform(), FourierShift(), AbsolutValues()]

    def apply(self, image_to_filter):
        content = image_to_filter
        for filter in self.filters:
            content = filter.apply(content)
            self.results[filter.__class__.__name__] = content
        return content


class FourierProcessQuarters(Filter):

    def __init__(self, fft_transform_abs):
        self._filters = [self._get_firsts_quarters,
                         self._apply_mask_fourier,
                         self._fill_complete_quarters,
                         self._getting_reversed_masks,
                         self._fill_complete_mask]
        self.fft_transform_abs = fft_transform_abs
        self._ny, self._nx = fft_transform_abs.shape
        self._mid_y, self._y_odd = divmod(self._ny, 2)
        self._mid_x, self._x_odd = divmod(self._nx, 2)
        self._margin = 10

    def apply(self, *args):
        content = None
        for filter in self._filters:
            content = filter(content)
        return content

    def _get_firsts_quarters(self, args=None):
        """
        Get first (upper left) and second (upper right) quarter from Fourier
        transform image, removing central strip with a .
        """
        fst_quarter_fourier = \
            self.fft_transform_abs[:self._mid_y - self._margin,
            :self._mid_x - self._margin]
        snd_quarter_fourier = \
            self.fft_transform_abs[:self._mid_y - self._margin,
            self._mid_x + self._margin +
            self._x_odd:self._nx]
        return fst_quarter_fourier, snd_quarter_fourier

    def _apply_mask_fourier(self, quarters):
        """
        Apply detection blanks fourier algorithm to first two quarters of the
        image.

        Parameters
        ----------
        quarters: tuple(ndarray, ndarray)
            images to apply fourier blank detection

        Returns
        -------
            tuple(ndarray, ndarray)
                tuple of masks of blank fourier detected for each quarter
        """
        mask_quarters = tuple(map(MaskFourier().apply, quarters))
        return mask_quarters

    def _fill_complete_quarters(self, quarters):
        """
        Create quarters of base image with zeros values (these quarters
        contains also margin and central line). After creation these quarters
        are filled with quarters input. They suposed to be mask of blank fourier
        detected previously.

        Parameters
        ----------
        quarters: tuple(ndarray, ndarray)
            quarters that are going to be place inside the quarter of real size
            the image

        Returns
        -------
        first and second quarters of real size of the image filled with mask
        fourier detected.
        """
        fst_complete_quarter = np.zeros((self._mid_y, self._mid_x))
        snd_complete_quarter = np.zeros((self._mid_y, self._mid_x))
        fst_complete_quarter[:self._mid_y - self._margin,
        :self._mid_x - self._margin] = quarters[0]
        snd_complete_quarter[:self._mid_y - self._margin,
        self._margin:self._mid_x] = quarters[1]
        return fst_complete_quarter, snd_complete_quarter

    def _getting_reverse_indices(self):
        """
        Get indices mesh of images reversed

        Returns
        -------
            Combination of pairs of indices to reverse some image.
        """
        reverse_x = (self._mid_x - 1) - np.arange(self._mid_x)
        reverse_y = (self._mid_y - 1) - np.arange(self._mid_y)
        indices = np.ix_(reverse_y, reverse_x)
        return indices

    def _getting_reversed_masks(self, quarters):
        """
        Create images reversed of input images.

        Parameters
        ----------
        quarters: tuple(ndarray, ndarray)
            images to be reversed

        Returns
        -------
            tuple(ndarray, ndarray, ndarray, ndarray)
                tuple of four images, the first two are the input images, while
                the second ones are the reversed images.
        """
        indices = self._getting_reverse_indices()
        trd_complete_quarter = quarters[1][indices]
        fth_complete_quarter = quarters[0][indices]

        return (quarters[0], quarters[1], trd_complete_quarter,
                fth_complete_quarter)

    def _fill_complete_mask(self, quarters):
        """
        Assemble the complete fourier mask using quarters provided as input

        Parameters
        ----------
        quarters: tuple(ndarray, ndarray, ndarray, ndarray)
            images needed to assemble the final fourier mask.
        Returns
        -------
            ndarray
                fourier mask complete.
        """
        masks_fourier = np.zeros((self._ny, self._nx))
        masks_fourier[:self._mid_y, :self._mid_x] = quarters[0]
        masks_fourier[:self._mid_y,
        self._mid_x + self._x_odd:self._nx] = quarters[1]
        masks_fourier[self._mid_y + self._y_odd:self._ny,
        :self._mid_x] = quarters[2]
        masks_fourier[self._mid_y + self._y_odd:self._ny,
        self._mid_x + self._x_odd:self._nx] = quarters[3]
        return masks_fourier


class DetectApplyFourier(ComposedFilter):
    def __init__(self):
        self.initial = FourierInitial()

    def apply(self, image_to_filter):
        self.fft_transform_abs = self.initial.apply(image_to_filter)
        self.filters = [FourierProcessQuarters(self.fft_transform_abs),
                        SubtractionFilter(minuend=1),
                        ProductFilter(
                            factor=self.initial.results["FourierShift"]),
                        FourierIShift(), FourierITransform(), AbsolutValues()]
        content = None
        return super().apply(content)


class SRTMProcess(ComposedFilter):

    def apply(self, srtm_to_process, tree_class_raw):
        tree_class = \
            BinaryClosing(structure=np.ones((3, 3))).apply(tree_class_raw)
        self.filters = [DetectApplyFourier(),
                        GrovesCorrectionsIter(tree_class)]
        return super().apply(srtm_to_process)


class PostProcessingFinal(ComposedFilter):

    def __init__(self):
        self.filters = [Convolve(), Around()]
